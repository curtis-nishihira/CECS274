package tester;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner; 
  
// A directed graph using 
// adjacency list representation 
public class test {
	public int temp;
	private int V;   // No. of vertices
	public static int edgeCount=Integer.parseInt(input().get(0));
	public static int counter1= 0;
	public static int counter2 = 0;
	public static int start = 0;
	static int [][] arr = new int[edgeCount+1][edgeCount];
	public static ArrayList<Integer> global = new ArrayList<Integer>();
	  
    // Array  of lists for Adjacency List Representation 
    private LinkedList<Integer> adj[]; 
  
    // Constructor 
    test(int v) 
    { 
        V = v; 
        adj = new LinkedList[v]; 
        for (int i=0; i<v; ++i) 
            adj[i] = new LinkedList(); 
    } 
  
    //Function to add an edge into the graph 
    void addEdge(int v, int w) 
    { 
        adj[v].add(w);  // Add w to v's list. 
    } 
  
    // A function used by DFS 
    void DFSUtil(int v,boolean visited[],boolean alphaVisit[], int [] checkList) 
    { 
        // Mark the current node as visited and print it 
    	visited[v] = true;
    	//System.out.println("visited: "+v);
        temp = v;
        arr[counter1][counter2] = v;
        counter2++;
        //}
  
        // Recur for all the vertices adjacent to this vertex 
        Iterator<Integer> i = adj[v].listIterator(); 
        while (i.hasNext()) 
        { 
            int n = i.next();
            //System.out.println(n);
            if (!visited[n]) 
            {
                DFSUtil(n, visited, alphaVisit, checkList);
            }
            if(visited[n]) 
            {
            	//System.out.println(n);
            	if((start == n)||Arrays.asList(checkList).contains(n))
            	{	
            		global.add(v);
            		//System.out.println(Arrays.toString(checkList));
	            	//System.out.println(Arrays.toString(alphaVisit));
	            	//DFSUtil(start, visited, alphaVisit, checkList);
	            	
	            }
            	
            }
            	
        }
        
           
         
    } 
  
    // The function to do DFS traversal. It uses recursive DFSUtil() 
    void DFS(int v) 
    { 
        // Mark all the vertices as not visited(set as 
        // false by default in java) 
        boolean visited[] = new boolean[V];
        boolean alphaVisit[] = new boolean[V];
        int [] checkList = new int[edgeCount+1];
        // Call the recursive helper function to print DFS traversal 
        counter2 = 0;
        global.clear();
        DFSUtil(v, visited, alphaVisit,checkList);
        
    }
    public static ArrayList<String> input() 
	{
		ArrayList<String> list1 = new ArrayList<String>();

		File file = new File ("input copy.txt");
		try 
		{
			Scanner scan = new Scanner(file);
			while(scan.hasNextLine())
			{
	    		list1.add(scan.nextLine());
	    	}
			scan.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		return list1;
	}
    public static ArrayList<Integer> format()
	{
		ArrayList<String> string = input();
		ArrayList<Integer> numberList = new ArrayList<Integer>();
		for(int i = 1; i<string.size();i++) {
			String test = string.get(i);
			String numbers[] = test.split(",");
			numberList.add(Integer.parseInt(numbers[0]));
			numberList.add(Integer.parseInt(numbers[1]));
		}
		return numberList;
	}
      
 // Driver method to 
 public static void main(String args[]) 
 { 
	 ArrayList<Integer> inst = format();
     ArrayList<Integer> answer = new ArrayList<Integer>();
     boolean isAlpha = false;
     test g = new test(edgeCount+1); 
     for(int i = 1; i<inst.size();i+=2)
     {
    	 g.addEdge(inst.get(i-1), inst.get(i));
     }
     for(int i = 1; i<=edgeCount;i++) 
     {
    	 start = i;
    	 g.DFS(i);
    	 counter1++;
    	 ArrayList<Integer> temp = new ArrayList<Integer>();
         for(int j = 1; arr[0][j]!=0; j++)
         {
        	if(!global.contains(arr[0][j]))
        	{
        	 	temp.add(arr[0][j]);
        	}
        	 
         }
    	 
         //System.out.println(Arrays.deepToString(arr));
         //System.out.println(temp);
     }
     start = 144;
     g.DFS(144);
     System.out.println(global);
     ArrayList<Integer> temp = new ArrayList<Integer>();
     //System.out.println(global);
     for(int i = 0; arr[start-1][i]!=0; i++)
     {
    	if(!global.contains(arr[start-1][i]))
    	{
    	 	temp.add(arr[start-1][i]);
    	}
    	 
     }
     temp.remove(new Integer(start));
     for(int t = 0;t<temp.size();t++) 
     {
    	 for(int gl = 0; gl<global.size();gl++) 
    	 {
    		 for(int d = 0;d<edgeCount;d++ ) 
    		 {
    			//System.out.println("gl: "+global.get(gl)+":"+arr[temp.get(t)-1][d]);
	    		if(temp.size()==1)
	    		{
	    			t = 0;
    			 	if(global.get(gl)==arr[temp.get(t)-1][d]) 
	    			 {
	     				System.out.println(t);
	     				System.out.println("remove"+temp.get(t));
	    				temp.remove(new Integer (temp.get(t)));
	    				System.out.println(temp);
	    				
	    				
	    			 }
    			 	
	    		}
	    		else if(temp.size()==0)
	    		{
	    			answer.add(start);
	    			break;
	    		}
	    		
	    		else
	    		{
	    			if(global.get(gl)==arr[temp.get(t)-1][d]) 
	    			 {
	     				System.out.println(t);
	     				System.out.println("remove"+temp.get(t));
	    				temp.remove(new Integer (temp.get(t)));
	    				System.out.println(temp);
	    				
	    				
	    			 }
	    		}
    			 	
    		 }
    	 }
     }
     //System.out.println(Arrays.deepToString(arr));
     System.out.println(temp);
     System.out.println(answer);
     
 }
} 
