import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.List;

import java.util.ArrayList; 
import java.util.LinkedList; 
import java.util.List; 
  
public class chimps { 
	static class graph{
		
	}
      
    private final int V; 
    private final List<List<Integer>> adj; 
  
    public chimps(int V)  
    { 
        this.V = V; 
        adj = new ArrayList<>(V); 
          
        for (int i = 0; i < V; i++) 
            adj.add(new LinkedList<>()); 
    } 
      
    // This function is a variation of DFSUytil() in  
    // https://www.geeksforgeeks.org/archives/18212 
    private boolean isCyclicUtil(int i, boolean[] visited, 
                                      boolean[] recStack)  
    { 
          
        // Mark the current node as visited and 
        // part of recursion stack 
        if (recStack[i]) 
        {
        	//System.out.println(i);
        	return true;
        }
  
        if (visited[i])
        {
            return false;
        }
              
        visited[i] = true; 
  
        recStack[i] = true; 
        List<Integer> children = adj.get(i); 
          
        for (Integer c: children)
        {
            if (isCyclicUtil(c, visited, recStack))
            {
                //System.out.println(c);
            	return true;
            }
        }
                  
        recStack[i] = false; 
  
        return false; 
    } 
  
    private void add(int source, int dest) { 
        adj.get(source).add(dest); 
    } 
  
    // Returns true if the graph contains a  
    // cycle, else false. 
    // This function is a variation of DFS() in  
    // https://www.geeksforgeeks.org/archives/18212 
    private boolean isCyclic()  
    { 
          
        // Mark all the vertices as not visited and 
        // not part of recursion stack 
        boolean[] visited = new boolean[V]; 
        boolean[] recStack = new boolean[V]; 
          
          
        // Call the recursive helper function to 
        // detect cycle in different DFS trees 
        for (int i = 0; i < V; i++) 
            if (isCyclicUtil(i, visited, recStack))
            {
            	System.out.println(i);
            	System.out.println(Arrays.toString(visited));
            	System.out.println(Arrays.toString(recStack));
            	
            	return true;
            }
  
        return false; 
    } 

    public static ArrayList<String> input() 
	{
		ArrayList<String> list1 = new ArrayList<String>();

		File file = new File ("input.txt");
		try 
		{
			Scanner scan = new Scanner(file);
			while(scan.hasNextLine())
			{
	    		list1.add(scan.nextLine());
	    	}
			scan.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		return list1;
	}
	
	public static void output(ArrayList<Integer> array)
	{
		File file = new File("output.txt");
		FileOutputStream stream = null;
		try {
			stream = new FileOutputStream(file);
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
		}
		PrintWriter writer = new PrintWriter(stream);
		for(int i = 0; i<array.size();i++)
		{
			writer.println(array.get(i));
		}
		writer.close();
		try {
			stream.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	public static ArrayList<Integer> format()
	{
		ArrayList<String> string = input();
		ArrayList<Integer> numberList = new ArrayList<Integer>();
		for(int i = 1; i<string.size();i++) {
			String test = string.get(i);
			String numbers[] = test.split(",");
			numberList.add(Integer.parseInt(numbers[0]));
			numberList.add(Integer.parseInt(numbers[1]));
			
		}
		return numberList;
	}
	  
    public static void main(String args[]) 
    { 
       ArrayList<Integer> inst = format();
       ArrayList<Integer> answer = new ArrayList<Integer>();
       int edgeCount = Integer.parseInt(input().get(0));
       chimps g = new chimps(edgeCount+1); 
       for(int i = 1; i<inst.size();i+=2)
       {
    		g.add(inst.get(i-1), inst.get(i));
       }
  
        /*for(int i = 1; i<=edgeCount;i++)
    	{
    		g.search(i);
    		if(i == alpha) 
    		{
    			answer.add(alpha);
    		}
    		
    	}*/
       if(g.isCyclic()) 
           System.out.println("Graph contains cycle"); 
       else
           System.out.println("Graph doesn't "
                                   + "contain cycle");
       output(answer);
       System.out.println(answer);
    } 

	
	
}
